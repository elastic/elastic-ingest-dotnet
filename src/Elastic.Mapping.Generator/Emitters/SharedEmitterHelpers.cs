// Licensed to Elasticsearch B.V under one or more agreements.
// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.
// See the LICENSE file in the project root for more information

using System.Security.Cryptography;
using System.Text;
using Elastic.Mapping.Generator.Model;

namespace Elastic.Mapping.Generator.Emitters;

/// <summary>
/// Shared helpers used by context and resolver emitters.
/// </summary>
internal static class SharedEmitterHelpers
{
	internal const int GeneratorMajorVersion = 1;

	public static void EmitHeader(StringBuilder sb)
	{
		sb.AppendLine("// Licensed to Elasticsearch B.V under one or more agreements.");
		sb.AppendLine("// Elasticsearch B.V licenses this file to you under the Apache 2.0 License.");
		sb.AppendLine("// See the LICENSE file in the project root for more information");
		sb.AppendLine();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
	}

	public static string GenerateSettingsJson(TypeMappingModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("{");

		var idx = model.IndexConfig;
		var settingsList = new List<string>();

		if (idx != null && idx.Shards > 0)
			settingsList.Add($"\t\"number_of_shards\": {idx.Shards}");

		if (idx != null && idx.Replicas >= 0)
			settingsList.Add($"\t\"number_of_replicas\": {idx.Replicas}");

		if (idx != null && !string.IsNullOrEmpty(idx.RefreshInterval))
			settingsList.Add($"\t\"refresh_interval\": \"{idx.RefreshInterval}\"");

		if (settingsList.Count > 0)
			sb.AppendLine(string.Join(",\n", settingsList));

		sb.Append("}");

		return sb.ToString();
	}

	public static string GenerateMappingsJson(TypeMappingModel model)
	{
		var sb = new StringBuilder();
		sb.AppendLine("{");

		if (model.IndexConfig != null && !model.IndexConfig.Dynamic)
			sb.AppendLine("\t\"dynamic\": false,");

		sb.AppendLine("\t\"properties\": {");

		var props = model.Properties.Where(p => !p.IsIgnored).ToList();
		for (var i = 0; i < props.Count; i++)
		{
			var prop = props[i];
			var isLast = i == props.Count - 1;

			if (prop.FieldType == FieldTypes.Text)
			{
				sb.Append($"\t\t\"{prop.FieldName}\": {{ \"type\": \"text\"");

				foreach (var opt in prop.Options)
				{
					var jsonKey = ToSnakeCase(opt.Key);
					sb.Append($", \"{jsonKey}\": {opt.Value}");
				}

				sb.Append(", \"fields\": { \"keyword\": { \"type\": \"keyword\", \"ignore_above\": 256 } } }");
			}
			else
			{
				sb.Append($"\t\t\"{prop.FieldName}\": {{ \"type\": \"{prop.FieldType}\"");

				foreach (var opt in prop.Options)
				{
					var jsonKey = ToSnakeCase(opt.Key);
					sb.Append($", \"{jsonKey}\": {opt.Value}");
				}

				sb.Append(" }");
			}

			sb.AppendLine(isLast ? "" : ",");
		}

		sb.AppendLine("\t}");
		sb.Append("}");

		return sb.ToString();
	}

	public static string GenerateIndexJson(string settingsJson, string mappingsJson)
	{
		var sb = new StringBuilder();
		sb.AppendLine("{");
		sb.AppendLine($"\t\"settings\": {settingsJson},");
		sb.AppendLine($"\t\"mappings\": {mappingsJson}");
		sb.Append("}");

		return sb.ToString();
	}

	public static string ComputeHash(string content)
	{
		var input = $"v{GeneratorMajorVersion}:{Minify(content)}";
		using var sha = SHA256.Create();
		var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
		return BitConverter.ToString(bytes).Replace("-", "").Substring(0, 16).ToLowerInvariant();
	}

	public static void EmitRawStringLiteral(StringBuilder sb, string json, string indent)
	{
		sb.AppendLine($"{indent}\"\"\"");
		foreach (var line in json.Split('\n'))
			sb.AppendLine($"{indent}{line.TrimEnd('\r')}");
		sb.AppendLine($"{indent}\"\"\";");
	}

	public static void EmitFieldsClass(StringBuilder sb, TypeMappingModel model, string indent)
	{
		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Field name constants.</summary>");
		sb.AppendLine($"{indent}public sealed class FieldNames");
		sb.AppendLine($"{indent}{{");

		foreach (var prop in model.Properties.Where(p => !p.IsIgnored))
			sb.AppendLine($"{indent}\tpublic string {prop.PropertyName} => \"{prop.FieldName}\";");

		sb.AppendLine($"{indent}}}");
		sb.AppendLine();

		sb.AppendLine($"{indent}/// <summary>Field name constants for this type.</summary>");
		sb.AppendLine($"{indent}public FieldNames Fields {{ get; }} = new();");
	}

	public static void EmitFieldMappingClass(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var props = model.Properties.Where(p => !p.IsIgnored).ToList();

		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Field name mapping dictionaries.</summary>");
		sb.AppendLine($"{indent}public sealed class FieldMappings");
		sb.AppendLine($"{indent}{{");

		sb.AppendLine($"{indent}\t/// <summary>Maps C# property name to ES|QL field name.</summary>");
		sb.AppendLine($"{indent}\tpublic global::System.Collections.Generic.IReadOnlyDictionary<string, string> PropertyToField {{ get; }} = new global::System.Collections.Generic.Dictionary<string, string>");
		sb.AppendLine($"{indent}\t{{");
		foreach (var prop in props)
			sb.AppendLine($"{indent}\t\t[\"{prop.PropertyName}\"] = \"{prop.FieldName}\",");
		sb.AppendLine($"{indent}\t}};");
		sb.AppendLine();

		sb.AppendLine($"{indent}\t/// <summary>Maps ES|QL field name to C# property name.</summary>");
		sb.AppendLine($"{indent}\tpublic global::System.Collections.Generic.IReadOnlyDictionary<string, string> FieldToProperty {{ get; }} = new global::System.Collections.Generic.Dictionary<string, string>");
		sb.AppendLine($"{indent}\t{{");
		foreach (var prop in props)
			sb.AppendLine($"{indent}\t\t[\"{prop.FieldName}\"] = \"{prop.PropertyName}\",");
		sb.AppendLine($"{indent}\t}};");

		sb.AppendLine($"{indent}}}");
		sb.AppendLine();

		sb.AppendLine($"{indent}/// <summary>Field name mapping dictionaries for this type.</summary>");
		sb.AppendLine($"{indent}public FieldMappings FieldMapping {{ get; }} = new();");
	}

	public static void EmitIgnoredProperties(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var ignored = model.Properties.Where(p => p.IsIgnored).ToList();

		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Property names marked with [JsonIgnore].</summary>");
		sb.Append($"{indent}public global::System.Collections.Generic.IReadOnlySet<string> IgnoredProperties {{ get; }} = ");

		if (ignored.Count == 0)
			sb.AppendLine("new global::System.Collections.Generic.HashSet<string>();");
		else
		{
			sb.AppendLine("new global::System.Collections.Generic.HashSet<string>");
			sb.AppendLine($"{indent}{{");
			foreach (var prop in ignored)
				sb.AppendLine($"{indent}\t\"{prop.PropertyName}\",");
			sb.AppendLine($"{indent}}};");
		}
	}

	public static void EmitGetPropertyMap(StringBuilder sb, TypeMappingModel model, string typeFqn, string indent)
	{
		var props = model.Properties.Where(p => !p.IsIgnored).ToList();

		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Gets PropertyInfo lookup keyed by field name (for deserialization).</summary>");
		sb.AppendLine($"{indent}public global::System.Collections.Generic.Dictionary<string, global::System.Reflection.PropertyInfo> GetPropertyMap() => new()");
		sb.AppendLine($"{indent}{{");

		foreach (var prop in props)
		{
			sb.AppendLine($"{indent}\t[\"{prop.FieldName}\"] = typeof(global::{typeFqn}).GetProperty(nameof(global::{typeFqn}.{prop.PropertyName}))!,");

			if (prop.PropertyName != prop.FieldName)
				sb.AppendLine($"{indent}\t[\"{prop.PropertyName}\"] = typeof(global::{typeFqn}).GetProperty(nameof(global::{typeFqn}.{prop.PropertyName}))!,");

			var camelCase = ToCamelCase(prop.PropertyName);
			if (camelCase != prop.FieldName && camelCase != prop.PropertyName)
				sb.AppendLine($"{indent}\t[\"{camelCase}\"] = typeof(global::{typeFqn}).GetProperty(nameof(global::{typeFqn}.{prop.PropertyName}))!,");
		}

		sb.AppendLine($"{indent}}};");
	}

	public static void EmitTextFieldsSet(StringBuilder sb, TypeMappingModel model, string indent)
	{
		var textProps = model.Properties
			.Where(p => !p.IsIgnored && p.FieldType == FieldTypes.Text)
			.ToList();

		sb.AppendLine();
		sb.AppendLine($"{indent}/// <summary>Property names that map to text fields.</summary>");
		sb.Append($"{indent}public global::System.Collections.Generic.IReadOnlySet<string> TextFields {{ get; }} = ");

		if (textProps.Count == 0)
			sb.AppendLine("new global::System.Collections.Generic.HashSet<string>();");
		else
		{
			sb.AppendLine("new global::System.Collections.Generic.HashSet<string>");
			sb.AppendLine($"{indent}{{");
			foreach (var prop in textProps)
				sb.AppendLine($"{indent}\t\"{prop.PropertyName}\",");
			sb.AppendLine($"{indent}}};");
		}
	}

	public static string ToCamelCase(string name)
	{
		if (string.IsNullOrEmpty(name))
			return name;

		if (name.Length == 1)
			return name.ToLowerInvariant();

		return char.ToLowerInvariant(name[0]) + name.Substring(1);
	}

	public static string ToSnakeCase(string name)
	{
		var sb = new StringBuilder();
		for (var i = 0; i < name.Length; i++)
		{
			var c = name[i];
			if (char.IsUpper(c))
			{
				if (i > 0)
					sb.Append('_');
				sb.Append(char.ToLowerInvariant(c));
			}
			else
			{
				sb.Append(c);
			}
		}

		return sb.ToString();
	}

	private static string ExtractJsonContent(string json, string key)
	{
		var keyPattern = $"\"{key}\":";
		var startIndex = json.IndexOf(keyPattern, StringComparison.Ordinal);
		if (startIndex < 0)
			return "{}";

		startIndex += keyPattern.Length;

		while (startIndex < json.Length && char.IsWhiteSpace(json[startIndex]))
			startIndex++;

		var braceCount = 0;
		var endIndex = startIndex;
		for (var i = startIndex; i < json.Length; i++)
		{
			if (json[i] == '{')
				braceCount++;
			else if (json[i] == '}')
			{
				braceCount--;
				if (braceCount == 0)
				{
					endIndex = i + 1;
					break;
				}
			}
		}

		return json.Substring(startIndex, endIndex - startIndex);
	}

	private static string Minify(string json)
	{
		var sb = new StringBuilder();
		var inString = false;

		for (var i = 0; i < json.Length; i++)
		{
			var c = json[i];

			if (c == '"' && (i == 0 || json[i - 1] != '\\'))
				inString = !inString;

			if (inString || !char.IsWhiteSpace(c))
				sb.Append(c);
		}

		return sb.ToString();
	}
}
